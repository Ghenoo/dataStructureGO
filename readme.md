# Estrutura de dados em GO (DSA in GO)

Este projeto é uma coleção abrangente de implementações de Estrutura de Dados e Algoritmos em GoLang. O objetivo é fornecer uma visão clara de como essas estruturas funcionam e como são implementadas na linguagem Go. É um recurso ideal tanto para iniciantes quanto para desenvolvedores experientes que desejam revisar ou aprender estruturas de dados e algoritmos.

## Referência

- [Introdução](#Introdução)
- [Algoritmos](#Algoritmos)
- [Estruturas de Dados](#Estruturas-de-Dados)
- [Análise de Complexidade](#Análise-de-Complexidade)
- [Contribuição](#Contribuição)
- [Licença](#Licença)


## Introdução
Neste projeto, você encontrará implementações de algoritmos e estruturas de dados que são fundamentais para a ciência da computação. Esses conceitos são essenciais para resolver problemas complexos de forma eficiente e são amplamente utilizados em sistemas de software do mundo real. Cada implementação é acompanhada de explicações detalhadas e exemplos para facilitar o entendimento.

## Algoritmos
Aqui estão alguns dos algoritmos abordados:

- Algoritmo Polinomial: Algoritmos cuja complexidade é uma função polinomial do tamanho da entrada (ex: O(n²), O(n³)).
- Algoritmo Constante: Algoritmos que possuem uma complexidade constante, ou seja, O(1).
- Algoritmo Linear: Algoritmos cuja complexidade cresce linearmente com o tamanho da entrada (ex: O(n)).

## Estruturas de Dados
As estruturas de dados implementadas incluem:

- Array: Estruturas de dados simples que armazenam elementos contíguos.
- Slice: Uma variação de arrays em Go, com redimensionamento dinâmico.
- Fila / Queue: Estrutura que segue o princípio FIFO (First In, First Out).
- Pilha / Stack: Estrutura que segue o princípio LIFO (Last In, First Out).
- Lista ligada / Linked List: Estruturas lineares onde os elementos são nós ligados através de ponteiros.
- Árvore / Tree: Estruturas hierárquicas que consistem de nós ligados, sendo o primeiro nó a raiz da árvore.

## Análise de Complexidade
Cada algoritmo e estrutura de dados vem acompanhado de uma análise de Complexidade de Tempo e Complexidade de Espaço, usando as seguintes notações:

- Notação Big O: Para representar o pior caso do algoritmo.
- Notação Ω: Para representar o melhor caso do algoritmo.
- Notação Θ: Para representar o caso médio.

## Contribuição
Contribuições são bem-vindas! Se você deseja melhorar as implementações existentes ou adicionar novos algoritmos, sinta-se à vontade para abrir um pull request.


## Licença

Este projeto está licenciado sob a [MIT License](./LICENSE).


